###OVERVIEW###
#ROUTINE:
	>Eat;
	>Think;
	>sleep;

#N amount of philosophers sit at a table (N > 0);

#Forks = Number of philos;

#Everyone needs 2 forks to eat;

#After eating they release the fork and go to sleep;

#After sleeping they think again;

#Simulation stops when someone dies;

#Everyone has to eat;

#They don't speak to eachother;

#They don't know when the others will die;

#They shouldn't die;

###GOLBAL RULES###

#No global vars;

#Args:
	>nbr_of_philos - Number of philos and also the number of forks;
	>time_to_die (ms) - it they dont start to eat time_to_die since the beginning of the last meal or simulation they die;
	>time_to_eat (ms) - time spent eating (both forks are held during this time);
	>time_to_sleep (ms) - time spent sleeping;
	>nbr_of_times_each_philo_must_eat (optional) - after all philos ate at least nbr_of_times_each_philo_must_eat times simulation stops, otherwise it stops when someone dies;

#Each philo has a nbr from 1 to nbr_of_philos (philo_id);

#Siting is circular - philo nbr N sits after N - 1 and before N + 1;

#Output log
	>time_in_ms X has taken a fork
	>time_in_ms X is eating
	>time_in_ms X is sleeping
	>time_in_ms X is thinking
	>time_in_ms X died
	time_in_ms = current time
	X = philo nbr

#Messages shouldn't mix with eachother;

#Death message should be display with an error of no more than 10 ms;

#NO DATA RACES;

###MANDATORY###

#Each philo is a thread;

#One fork between each pair of philos. Fork on the left and another on the rigth of each philo. Single philo only one fork at the table;

#Each fork has to be protected with a mutex;

###BONUS###

#All forks are put on the middle of the table

#Nbr of forkks is represented with a semaphore;

#Each philo is a process. Except the main one;

##ALLOWED FUNCS

 >